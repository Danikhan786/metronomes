import NextAuth from "next-auth"
import { createAppleAuth } from "@/lib/apple-auth"
import AppleProvider from "next-auth/providers/apple"
import GoogleProvider from "next-auth/providers/google"
import { withAuth } from "next-auth/middleware"
import { DefaultSession, DefaultUser } from "next-auth"
import { FirebaseAdapter } from "@/lib/firebase-adapter"

const handler = NextAuth({
  adapter: FirebaseAdapter(),
  providers: [
    AppleProvider({
      clientId: process.env.APPLE_ID_CLIENT_ID!,
      clientSecret: process.env.APPLE_ID_PRIVATE_KEY!,
      authorization: {
        params: {
          scope: "name email",
          response_mode: "form_post",
        },
      },
    }),
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
    }),
  ],
  callbacks: {
    async jwt({ token, user, account }) {
      // Persist the OAuth access_token and or the user id to the token right after signin
      if (account) {
        token.accessToken = account.access_token
        token.refreshToken = account.refresh_token
        token.provider = account.provider
      }
      if (user) {
        token.id = user.id
        token.emailVerified = user.emailVerified
      }
      return token
    },
    async session({ session, token }) {
      // Send properties to the client, like an access_token and user id from a provider.
      session.user.id = token.id as string
      session.user.emailVerified = token.emailVerified as Date | null
      return session
    },
    async redirect({ url, baseUrl }: { url: string; baseUrl: string }) {
      // Handle OAuth callback URLs
      if (url.includes('/api/auth/callback/')) {
        return `${baseUrl}/`
      }
      
      // Redirect to main page after successful sign in
      if (url.startsWith(baseUrl)) {
        return `${baseUrl}/`
      }
      
      // Allows relative callback URLs
      else if (url.startsWith("/")) {
        return `${baseUrl}${url}`
      }
      
      return baseUrl
    },
    async signIn({ user, account, profile }) {
      // Handle OAuthAccountNotLinked error by allowing users to link accounts
      if (account?.provider === "apple") {
        // Handle Apple-specific sign-in logic
        try {
          const appleAuth = createAppleAuth()
          
          // If we have an authorization code, exchange it for tokens
          if (account.code) {
            const redirectUri = `${process.env.NEXTAUTH_URL}/api/auth/callback/apple`
            const tokens = await appleAuth.exchangeCodeForTokens(
              account.code,
              redirectUri
            )
            
            // Store the refresh token for later use
            if (tokens.refresh_token) {
              account.refresh_token = tokens.refresh_token
            }
            if (tokens.access_token) {
              account.access_token = tokens.access_token
            }
          }
          
          // Verify the ID token if available
          if (account.id_token) {
            const userInfo = await appleAuth.verifyIdToken(account.id_token)
            
            // Update user information if needed
            if (userInfo.email && !user.email) {
              user.email = userInfo.email
            }
            
            if (userInfo.name && !user.name) {
              user.name = `${userInfo.name.firstName || ""} ${userInfo.name.lastName || ""}`.trim()
            }
          }
          
          return true
        } catch (error) {
          console.error("Apple sign-in error:", error)
          // Don't fail the sign-in, just log the error
          return true
        }
      }

      // Handle OAuthAccountNotLinked error for all providers
      if (account && user.email) {
        console.log("SignIn callback - Checking for existing user with email:", user.email)
        
        try {
          const adapter = FirebaseAdapter()
          // Check if there's already a user with this email
          const existingUser = await adapter.getUserByEmail(user.email)
          
          if (existingUser) {
            console.log("Found existing user:", existingUser.id)
            
            // Check if the existing user already has an account with this provider
            const existingAccount = await adapter.getUserByAccount({
              provider: account.provider,
              providerAccountId: account.providerAccountId
            })
            
            if (!existingAccount) {
              console.log("Linking new account to existing user")
              // User exists but doesn't have this provider linked
              // Link the new account to the existing user
              await adapter.linkAccount({
                id: '', // Will be generated by the adapter
                userId: existingUser.id,
                type: account.type,
                provider: account.provider,
                providerAccountId: account.providerAccountId,
                refresh_token: account.refresh_token,
                access_token: account.access_token,
                expires_at: account.expires_at,
                token_type: account.token_type,
                scope: account.scope,
                id_token: account.id_token,
                session_state: account.session_state,
              })
              
              // Update the user object to use the existing user's ID
              user.id = existingUser.id
              console.log("Account linked successfully, returning true")
              return true
            } else {
              console.log("Account already exists for this provider")
            }
          } else {
            console.log("No existing user found, creating new user")
          }
        } catch (error) {
          console.error("Error in account linking logic:", error)
          // If there's an error, still allow the sign-in to proceed
          return true
        }
      }
      
      // Allow sign in for all providers
      return true
    },
  },
  pages: {
    signIn: "/auth/signin",
    error: "/auth/error",
  },
  session: {
    strategy: "jwt",
  },
  secret: process.env.NEXTAUTH_SECRET,
  debug: true,
})

export { handler as GET, handler as POST }

declare module "next-auth" {
  interface Session {
    user: { id: string; email: string; name?: string | null; image?: string | null; emailVerified?: Date | null } & DefaultSession["user"];
  }
  interface User extends DefaultUser { emailVerified?: Date | null }
} 